#ifndef __SIMPLE_LIBC_STRING__
#define __SIMPLE_LIBC_STRING__

#include <string.h>
#include <wchar.h>

namespace std {
    template <class T>
    size_t __strlen(const T *str)
    {
        size_t result = 0;
        for (; str[result]; result++);
        return result;
    }

    template <class T>
    T * __strcpy(T *dst, const T *src)
    {
        T *result = dst;
        while ((*dst++ = *src++) != 0);
        return result;
    }

    static char * __strstr(const char *haystack, const char *needle)
    {
        return strstr(haystack, needle);
    }
    static char * __strchr(const char *str, int c)
    {
        return strchr(str, c);
    }

    template <class T>
    T * __memcpy(T *dst, const T *src, size_t count)
    {
        return (T *)memcpy((void *)dst, (void *)src, count * sizeof(T));
    }

    template <class T>
    T * __memmove(T *dst, const T *src, size_t count)
    {
        return (T *)memmove((void *)dst, (void *)src, count * sizeof(T));
    }

    template <class T>
    int __memcmp(const T *dst, const T *src, size_t count)
    {
        return memcmp((const void *)dst, (const void *)src, count * sizeof(T));
    }

    template <class T>
    T * __memset(T *dst, T t, size_t n)
    {
        T *tmp = dst;
        while (n) {
            *tmp++ = n;
        }
        return dst;
    }

    template <class T>
    class array_base {
    public:
        typedef T *iterator;
        typedef const T *const_iterator;
        typedef T &reference;
        typedef const T &const_reference;
        typedef size_t size_type;

        array_base<T>(const T *arr, size_t num)
            : __length(num)
        {
            if (__length > 0) {
                __array = (T *)malloc(__length * sizeof(T));
                VSF_ASSERT(__array != nullptr);
                if (arr != nullptr) {
                    __memcpy<T>(__array, arr, __length);
                }
            } else {
                __array = nullptr;
            }
        }
        array_base<T>(size_t num)
            : array_base<T>(nullptr, num) { }
        array_base<T>(const array_base &arr)
            : array_base<T>(arr.__array, arr.__length) { }
        ~array_base<T>()
        {
            __length = 0;
            if (__array != nullptr) {
                free(__array);
                __array = nullptr;
            }
        }

        bool empty() const
        {
            return (0 == __length);
        }
        const T & at(size_t pos) const
        {
            VSF_ASSERT(pos < __length);
            return __array[pos];
        }
        const T & back() const
        {
            return at(__length);
        }
        const T & front() const
        {
            return at(0);
        }
        size_t size() const
        {
            return __length * sizeof(T);
        }
        size_t length() const
        {
            return __length;
        }
        array_base<T> & append(const T *arr, size_t num)
        {
            if (arr != nullptr && num != 0) {
                __array = (T *)realloc(__array, (__length + num) * sizeof(T));
                VSF_ASSERT(__array != nullptr);
                __memcpy(&__array[__length], arr, num);
                __length += num;
            }
            return (*this);
        }
        array_base<T> & append(const array_base<T> &arr)
        {
            return append(arr.__array, arr.__length);
        }
        array_base<T> & assign(const array_base<T> &arr)
        {
            if (this == &arr) { return (*this); }

            free(__array);
            __array = nullptr;
            return append(arr);
        }
        array_base<T> & assign(const T *arr, size_t num)
        {
            if (this->__array == arr) { return (*this); }

            free(__array);
            __array = nullptr;
            return append(arr, num);
        }
        void clear()
        {
            assign((const T *)nullptr, 0);
        }
        void swap(array_base<T> &arr)
        {
            T * array = arr.__array;
            size_t length = arr.__length;
            arr.__array = __array;
            arr.__length = __length;
            __array = array;
            __length = length;
        }
        array_base<T> & replace(size_t pos, size_t len, const T *arr, size_t sublen)
        {
            if (sublen && !arr) {
                assert(false);
            }

            size_t newlen = __length + sublen - len;
            if (pos + len > __length) {
                len = __length - pos;
            }
            if (sublen > len) {
                __array = (T *)realloc(__array, newlen * sizeof(T));
            }
            __memmove(&__array[pos + len], &__array[pos + sublen], __length - pos - len);
            if (arr != nullptr) {
                __memcpy(&__array[pos], arr, sublen);
            }
            if (sublen < len) {
                __array = (T *)realloc(__array, newlen * sizeof(T));
            }
            return (*this);
        }
        array_base<T> & replace(size_t pos, size_t len, size_t n, T t)
        {
            size_t newlen = __length + n - len;
            if (pos + len > __length) {
                len = __length - pos;
            }
            if (n > len) {
                __array = (T *)realloc(__array, newlen * sizeof(T));
            }
            __memmove(&__array[pos + len], &__array[pos + n], __length - pos - len);
            __memset(&__array[pos], t, n);
            if (n < len) {
                __array = (T *)realloc(__array, newlen * sizeof(T));
            }
            return (*this);
        }
        array_base<T> & insert(size_t pos, const T *arr, size_t sublen)
        {
            return replace(pos, 0, arr, sublen);
        }
        array_base<T> & insert(size_t pos, size_t n, T t)
        {
            return replace(pos, 0, n, t);
        }
        array_base<T> & erase(size_t pos, size_t len)
        {
            return replace(pos, len, nullptr, 0);
        }

        iterator begin() const
        {
            return __array == nullptr ? (iterator)nullptr : &__array[0];
        }
        iterator end() const
        {
            return __array == nullptr ? (iterator)nullptr : &__array[__length];
        }
        iterator rbegin() const
        {
            return end();
        }
        iterator rend() const
        {
            return begin();
        }
        const_iterator cbegin() const
        {
            return __array == nullptr ? (const_iterator)nullptr : &__array[0];
        }
        const_iterator cend() const
        {
            return __array == nullptr ? (const_iterator)nullptr : &__array[__length];
        }
        const_iterator crbegin() const
        {
            return cend();
        }
        const_iterator crend() const
        {
            return cbegin();
        }

        const T & operator [](size_t pos) const
        {
            return at(pos);
        }
        bool operator ==(array_base<T> &arr) const
        {
            return (__length == arr.__length) && !__memcmp(__array, arr.__array, __length);
        }

    private:
        T * __array;
        size_t __length;
    };

    template <class T>
    class basic_string : public array_base<T> {
    public:
        static const size_t npos = -1;

        basic_string<T>(const T *str)
            : array_base<T>(str, __strlen(str) + 1) { }
        basic_string<T>(const basic_string<T> &s)
            : array_base<T>(s) { }
        basic_string<T>(size_t len)
            : array_base<T>(nullptr, len + 1) { }
        basic_string<T>()
            : array_base<T>(nullptr, 0) { }
        basic_string<T>(const T *arr, size_t num)
            : array_base<T>(arr, num) { }

        size_t size() const
        {
            return length();
        }
        size_t length() const
        {
            size_t len = array_base<T>::length();
            return len > 0 ? len - 1 : 0;
        }
        size_t capacity() const
        {
            return array_base<T>::size();
        }
        basic_string<T> & append(const T *arr, size_t num)
        {
            array_base<T>::append(arr, num);
            return (*this);
        }
        basic_string<T> & append(const T *str)
        {
            size_t size = __strlen<T>(str);
            if (size > 0) {
                array_base<T>::append(str, size);
            }
            return (*this);
        }
        basic_string<T> & append(const basic_string<T> &str)
        {
            return append(str.c_str());
        }
        basic_string<T> & append(size_t n, T c)
        {
            return (basic_string<T> &)(array_base<T>::insert(length(), n, c));
        }
        basic_string<T> & substr(size_t start = 0, size_t count = npos) const
        {
            size_t len = length();
            if (start >= len) {
                count = 0;
            }
            if (start + count > len) {
                count -= len - (start + count);
            }

            const T * sub = array_base<T>::cbegin();
            basic_string<T> *newstr = new basic_string<T>(&sub[start], count + 1);
            return (*newstr);
        }
        size_t find(const basic_string<T> & str, size_t pos = 0) const
        {
            const T *start = c_str();
            T *found = __strstr(start + pos, str.c_str());
            if (found) {
                return (found - start) / sizeof(T);
            }
            return -1;
        }

        basic_string<T> & replace(size_t pos, size_t len, const T *str, size_t sublen = -1)
        {
            size_t curlen = length();
            sublen = vsf_min(sublen, __strlen(str));
            if (pos > curlen) {
                assert(false);
//                throw out_of_range("out of range");
            }
            return (basic_string<T> &)array_base<T>::replace(pos, len, str, sublen);
        }
        basic_string<T> & replace(size_t pos, size_t len, const basic_string<T> &str, size_t subpos = 0, size_t sublen = -1)
        {
            if (subpos > str.length()) {
                assert(false);
//                throw out_of_range("out of range");
            }
            return replace(pos, len, str.c_str() + subpos, sublen);
        }
        basic_string<T> & erase(size_t pos = 0, size_t len = npos)
        {
            if (len == npos) {
                len = length() - pos;
            }
            return replace(pos, len, nullptr, 0);
        }
        const char * erase(const char *first, const char *last)
        {
            ssize_t pos = first - c_str();
            ssize_t pos_end = first - c_str();
            if (    (pos < 0 || pos >= length())
                ||  (pos_end < 0 || pos_end >= length())
                ||  (first > last)) {
                assert(false);
            }
            return replace(pos, pos_end - pos, NULL, 0).begin();
        }

        size_t find_first_of(const T *str, size_t pos = npos) const
        {
            const T *start = c_str();
            ssize_t curpos = 0;
            if (pos >= length()) {
                return -1;
            }

            while (curpos <= pos) {
                if (__strchr(str, start[curpos])) {
                    break;
                }
                curpos++;
            }
            return curpos <= pos ? curpos : -1;
        }
        size_t find_first_of(const basic_string<T> & str, size_t pos = npos) const
        {
            return find_first_of(str.c_str(), pos);
        }
        size_t find_first_of(char c, size_t pos = npos) const
        {
            const T str[2] = { c, (T)0 };
            return find_first_of(str, pos);
        }
        size_t find_first_not_of(const T *str, size_t pos = npos) const
        {
            const T *start = c_str();
            ssize_t curpos = 0;
            if (pos >= length()) {
                return -1;
            }

            while (curpos <= pos) {
                if (!__strchr(str, start[curpos])) {
                    break;
                }
                curpos++;
            }
            return curpos <= pos ? curpos : -1;
        }
        size_t find_first_not_of(const basic_string<T> & str, size_t pos = npos) const
        {
            return find_first_not_of(str.c_str(), pos);
        }
        size_t find_first_not_of(char c, size_t pos = npos) const
        {
            const T str[2] = { c, (T)0 };
            return find_first_not_of(str, pos);
        }

        size_t find_last_of(const T *str, size_t pos = npos) const
        {
            const T *start = c_str();
            ssize_t curpos = length() - 1;
            if (pos > curpos) {
                return -1;
            }

            while (curpos >= pos) {
                if (__strchr(str, start[curpos])) {
                    break;
                }
                curpos--;
            }
            return curpos >= pos ? curpos : -1;
        }
        size_t find_last_of(const basic_string<T> & str, size_t pos = npos) const
        {
            return find_last_of(str.c_str(), pos);
        }
        size_t find_last_of(char c, size_t pos = npos) const
        {
            const T str[2] = { c, (T)0 };
            return find_last_of(str, pos);
        }
        size_t find_last_not_of(const T *str, size_t pos = npos) const
        {
            const T *start = c_str();
            ssize_t curpos = length() - 1;
            if (pos > curpos) {
                return -1;
            }

            while (curpos >= pos) {
                if (!__strchr(str, start[curpos])) {
                    break;
                }
                curpos--;
            }
            return curpos >= pos ? curpos : -1;
        }
        size_t find_last_not_of(const basic_string<T> & str, size_t pos = npos) const
        {
            return find_last_not_of(str.c_str(), pos);
        }
        size_t find_last_not_of(char c, size_t pos = npos) const
        {
            const T str[2] = { c, (T)0 };
            return find_last_not_of(str, pos);
        }

        basic_string<T> & operator =(const T *s)
        {
            size_t size = (nullptr == s) ? 1 : __strlen(s) + 1;
            return (basic_string<T> &)(array_base<T>::assign(s, size));
        }
        basic_string<T> & operator =(const basic_string<T> &s)
        {
            return operator =(s.c_str());
        }
        basic_string<T> & operator +=(const T *s)
        {
            return (basic_string<T> &)(array_base<T>::insert(length() - 1, s, __strlen(s)));
        }
        basic_string<T> & operator +=(const basic_string<T> &s)
        {
            return operator +=(s.c_str());
        }
        basic_string<T> & operator +(const T *s) const
        {
            size_t curlen = length(), appendlen = __strlen(s);
            basic_string<T> *newstr = new basic_string<T>(curlen + appendlen);
            T *start = (T *)newstr->c_str();
            __memcpy(start, array_base<T>::begin(), curlen);
            __memcpy(start + curlen, s, appendlen);
            start[curlen + appendlen] = (T)0;
            return (*newstr);
        }
        basic_string<T> & operator +(const T c) const
        {
            const T tmp[2] = { c, (T)0 };
            return operator +(tmp);
        }
        basic_string<T> & operator +(const basic_string<T> &s) const
        {
            return operator +(s.c_str());
        }
        bool operator ==(const T *str) const
        {
            size_t arrlen = __strlen(str);
            return (length() == arrlen) && !__memcmp(c_str(), str, arrlen);
        }
        bool operator ==(const basic_string<T> &str) const
        {
            return operator ==(str.c_str());
        }
        bool operator !=(const T *str) const
        {
            return !operator ==(str);
        }
        bool operator !=(const basic_string<T> &str) const
        {
            return !operator ==(str);
        }
        bool operator >(const T *str) const
        {
            size_t arrlen = vsf_min(__strlen(str), length());
            return __memcmp(c_str(), str, arrlen) > 0;
        }
        bool operator >(const basic_string<T> &str) const
        {
            return operator >(str.c_str());
        }
        bool operator <(const T *str) const
        {
            size_t arrlen = vsf_min(__strlen(str), length());
            return __memcmp(c_str(), str, arrlen) < 0;
        }
        bool operator <(const basic_string<T> &str) const
        {
            return operator <(str.c_str());
        }

        const T * c_str() const
        {
            return array_base<T>::cbegin();
        }
    };

    template <class T>
    basic_string<T> & operator +(const T * const left, const basic_string<T> &right)
    {
        size_t leftlen = __strlen(left), rightlen = right.length();
        size_t len = leftlen + rightlen;
        basic_string<T> *newstr = new basic_string<T>(len);
        T *start = (T *)newstr->c_str();
        __memcpy(start, left, leftlen);
        __memcpy(start + leftlen, right.c_str(), rightlen);
        start[len] = (T)0;
        return (*newstr);
    }
    template <class T>
    basic_string<T> & operator +(const T left, const basic_string<T> &right)
    {
        const T str[2] = { left, (T)0 };
        return operator +(str, right);
    }

    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;

    // to_string
    string to_string(int value);
    string to_string(long value);
    string to_string(long long value);
    string to_string(unsigned value);
    string to_string(unsigned long value);
    string to_string(unsigned long long value);
    string to_string(float value);
    string to_string(double value);
    string to_string(long double value);
    // to_wstring
    wstring to_wstring(int value);
    wstring to_wstring(long value);
    wstring to_wstring(long long value);
    wstring to_wstring(unsigned value);
    wstring to_wstring(unsigned long value);
    wstring to_wstring(unsigned long long value);
    wstring to_wstring(float value);
    wstring to_wstring(double value);
    wstring to_wstring(long double value);
    // stox
    float stof(const string &str, size_t *idx = 0);
    float stof(const wstring &str, size_t *idx = 0);
    double stod(const string &str, size_t *idx = 0);
    double stod(const wstring &str, size_t *idx = 0);
    long double stold (const string &str, size_t *idx = 0);
    long double stold (const wstring &str, size_t *idx = 0);
    int stoi(const string &str, size_t *idx = 0, int base = 10);
    int stoi(const wstring &str, size_t *idx = 0, int base = 10);
    long stol(const string &str, size_t *idx = 0, int base = 10);
    long stol(const wstring &str, size_t *idx = 0, int base = 10);
    long long stoll(const string &str, size_t *idx = 0, int base = 10);
    long long stoll(const wstring &str, size_t *idx = 0, int base = 10);
    unsigned long stoul(const string &str, size_t *idx = 0, int base = 10);
    unsigned long stoul(const wstring &str, size_t *idx = 0, int base = 10);
    unsigned long long stoull(const string &str, size_t *idx = 0, int base = 10);
    unsigned long long stoull(const wstring &str, size_t *idx = 0, int base = 10);
}

#endif      // __SIMPLE_LIBC_STRING__
